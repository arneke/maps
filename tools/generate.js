import Mustache from 'mustache';
import fs from 'fs-extra';
import {ESLint} from 'eslint';
import {directories, ignore} from '../config.js';
import {dirname, join} from 'node:path';
import {fileURLToPath} from 'node:url';
import {resolve} from 'import-meta-resolve';

const moduleRegex = /^[A-Z](.*)\.js$/;
const header = '// This file is generated by tools/generate.js. DO NOT EDIT.\n';
Mustache.escape = text => text;

async function getNames(dir) {
  const names = await fs.readdir(dir);
  return names.filter(name => moduleRegex.test(name));
}

async function main() {
  const toolsDir = dirname(fileURLToPath(import.meta.url));
  const templatesDir = join(toolsDir, '../templates');
  const olDir = dirname(fileURLToPath(await resolve('ol', import.meta.url)));
  const libDir = join(toolsDir, '../lib');
  const eslint = new ESLint({fix: true});

  for (const type in directories) {
    const templateData =
      header +
      String(await fs.readFile(join(templatesDir, `${type}.js.mustache`)));

    const names = await getNames(join(olDir, directories[type]));
    for (const name of names) {
      const commonPath = join(directories[type], name);
      if (ignore.includes(commonPath)) {
        continue;
      }
      const context = {
        importName: `OL${name.replace('.js', '')}`,
        importPath: `ol/${commonPath}`,
        elementType: type,
        constructorName: name.replace('.js', ''),
      };

      let output = Mustache.render(templateData, context);
      const outputPath = join(libDir, commonPath);
      const results = await eslint.lintText(output, {filePath: outputPath});
      if (results.length !== 1) {
        throw new Error(
          `Expected a single linter result for ${outputPath}, got ${results.length}`
        );
      }
      const result = results[0];
      if (result.errorCount > 0) {
        throw new Error(`Unable to fix lint errors in ${outputPath}`);
      }
      if (result.output) {
        // ESLint fixed something
        output = result.output;
      }

      await fs.outputFile(outputPath, output);
    }
  }
}

main().catch(err => process.stderr.write(err.stack, () => process.exit(1)));
